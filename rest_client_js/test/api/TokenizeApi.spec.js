/**
 * MDES for Merchants
 * The MDES APIs are designed as RPC style stateless web services where each API endpoint represents an operation to be performed.  All request and response payloads are sent in the JSON (JavaScript Object Notation) data-interchange format. Each endpoint in the API specifies the HTTP Method used to access it. All strings in request and response objects are to be UTF-8 encoded.  Each API URI includes the major and minor version of API that it conforms to.  This will allow multiple concurrent versions of the API to be deployed simultaneously.  
 *
 * The version of the OpenAPI document: 1.2.7
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

const fs = require("fs");
const assert = require('assert');
const oauth = require('mastercard-oauth1-signer');
const mcapi = require('mastercard-client-encryption');
const forge = require("node-forge");

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD.
    define(['expect.js', process.cwd()+'/src/index'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    factory(require('expect.js'), require(process.cwd()+'/src/index'));
  } else {
    // Browser globals (root is window)
    factory(root.expect, root.MdesForMerchants);
  }
}(this, function(expect, MdesForMerchants) {
  'use strict';


  var getProperty = function(object, getter, property) {
    // Use getter method if present; otherwise, get the property directly.
    if (typeof object[getter] === 'function')
      return object[getter]();
    else
      return object[property];
  }

  var setProperty = function(object, setter, property, value) {
    // Use setter method if present; otherwise, set the property directly.
    if (typeof object[setter] === 'function')
      object[setter](value);
    else
      object[property] = value;
  }


  const CONFIG = {
    paths: [
      {
        path: "/tokenize",
        toEncrypt: [
          {
            element: "cardInfo.encryptedData",
            obj: "cardInfo"
          }],
        toDecrypt: [
          {
            element: "tokenDetail",
            obj: "tokenDetail.encryptedData"
          }
        ]
      },
      {
        path: "/searchTokens",
        toEncrypt: [
          {
            element: "cardInfo.encryptedData",
            obj: "cardInfo"
          }],
        toDecrypt: []
      },
      {
        path: "/getToken",
        toEncrypt: [],
        toDecrypt: [
          {
            element: "tokenDetail",
            obj: "tokenDetail.encryptedData"
          }]
      },
      {
        path: "/transact",
        toEncrypt: [],
        toDecrypt: [
          {
            element: "encryptedPayload",
            obj: "encryptedPayload.encryptedData"
          }]
      },
      {
        path: "/notifyTokenUpdated",
        toEncrypt: [
          {
            element: "encryptedPayload.encryptedData",
            obj: "encryptedPayload"
          }],
        toDecrypt: []
      }
    ],
  
  
    oaepPaddingDigestAlgorithm: 'SHA-256',
  
    ivFieldName: 'iv',
    encryptedKeyFieldName: 'encryptedKey',
    encryptedValueFieldName: 'encryptedData',
    oaepHashingAlgorithmFieldName: 'oaepHashingAlgorithm',
    publicKeyFingerprintFieldName: 'publicKeyFingerprint',
    publicKeyFingerprintType: "certificate",
  
    dataEncoding: 'hex',
  
    encryptionCertificate: "<TODO>",
    privateKey: "<TODO>"
  
  };

  const CONSUMER_KEY = ""; // TODO
  const SIGNING_KEY_PATH = ""; // TODO
  const KEY_ALIAS = ""; // TODO
  const KEY_PASSWORD = ""; // TODO

  function loadSigningKey(){
    const p12Content = fs.readFileSync(SIGNING_KEY_PATH, 'binary');
    const p12Asn1 = forge.asn1.fromDer(p12Content, false);
    const p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, false, KEY_PASSWORD);
    const keyObj = p12.getBags({
      friendlyName: KEY_ALIAS,
      bagType: forge.pki.oids.pkcs8ShroudedKeyBag
    }).friendlyName[0];
    return forge.pki.privateKeyToPem(keyObj.key);
  }
  
  function createRequestObj() {
    return {
      requestId: "123456",
      taskId: "123456",
      tokenType: "CLOUD",
      tokenRequestorId: "98765432101",
      cardInfo: {
        publicKeyFingerprint: "8FC11150A7508F14BACA07285703392A399CC57C",
        encryptedKey: "A1B2C3D4E5F6112233445566",
        oaepHashingAlgorithm: "SHA512",
        iv: "NA",
        encryptedData: {
          accountNumber: "5123456789012345",
          source: "CARD_ON_FILE",
          cardholderName: "John Doe",
          securityCode: "123",
          expiryYear: "21",
          expiryMonth: "09",
          billingAddress: {
            line1: "100 1st Street",
            line2: "Apt. 4B",
            city: "St. Louis",
            countrySubdivision: "MO",
            postalCode: "61000"
          }
        }
      }
    };
  }

  describe('TokenizeApi', function() {
    describe('createTokenize', function() {

      let service;

      before("create client", (done) => {
        const client = MdesForMerchants.ApiClient.instance;
        client.basePath = "https://sandbox.api.mastercard.com/mdes";
        const signingKey = loadSigningKey();
        // Add OAuth1.0a interceptor
        client.applyAuthToRequest = function(request) {
          const _end = request._end;
          request._end = function() {
              const authHeader = oauth.getAuthorizationHeader(request.url, request.method, JSON.stringify(request._data), CONSUMER_KEY, signingKey);
              request.req.setHeader('Authorization', authHeader);
              _end.call(request);
          };
          return request;
        };

        // Add FieldLevelEncryption interceptor
        service = new mcapi.Service(MdesForMerchants, CONFIG);
        done();
      });
            
      it("should call createTokenize successfully", function (done) {
        this.timeout(10000);
        let api = new service.TokenizeApi();
        api.createTokenize({
          tokenizeRequestSchema: createRequestObj()
        }, (error, data, response) => {
          assert.ok(data);
          assert.ok(data['decision'] === 'APPROVED');
          done();
        });
      });

    });
  });

}));
